#!/usr/bin/perl
# This is a generic update hook script for GIT repositories.
# Written by Martin Mares <mj@ucw.cz> and placed into public domain.

use strict;
use warnings;

use Getopt::Long;
use IO::File;
use File::Temp;
use POSIX;

my $mail_to;
my $subject_prefix = "GIT";
my $max_diff_size;

GetOptions(
	'mail-to=s' => \$mail_to,
	'subject-prefix=s' => \$subject_prefix,
	'max-diff-size=s' => \$max_diff_size,
) and @ARGV == 3 or die <<AMEN ;
Usage: $0 [<options>] <refname> <sha1-old> <sha1-new>

Options:
--mail-to=<address>	Send mail to the given address
--max-diff-size=<bytes>	If the diff is too long, send just a summary
--subject-prefix=<px>	Prefix subjects with [<px>] (default: GIT)
AMEN

my ($ref, $old, $new) = @ARGV;
$ref =~ s{^refs/heads/}{} or exit 0;
$old ne $new or exit 0;

my $repo = POSIX::getcwd();
$repo =~ s{.*/}{};

my $subj = '[' . $subject_prefix . ($ref eq 'master' ? '' : "/$ref") . ']';
my $out = File::Temp->new() or die;
my $outname = $out->filename;
$out->autoflush(1);
open ORIG_STDOUT, '>&', \*STDOUT;
close STDOUT;
open STDOUT, '>&', $out or die;

my @rev_list_options = ('--pretty', '--no-abbrev', '--date=iso');
my @diff_options = ('-C');

sub scan_branches() {
	# Is there any branch pointing to $new ?
	for (`git branch -v --no-abbrev`) {
		chomp;
		my ($name, $sha) = /^..(\S+)\s+(\S+)/ or die;
		if ($name ne $ref && $sha eq $new) {
			return $name;
		}
	}
	return;
}

sub scan_commits() {
	my @commits = ();
	for (`git rev-list $old..$new --pretty=format:"# %H (%P) %s"`) {
		chomp;
		/^# / or next;
		my ($hash, $parents, $subject) = m{^# (\S+) \(([^)]*)\) (.*)} or die;
		push @commits, {
			hash => $hash,
			parents => [ split /\s+/, $parents ],
			subject => $subject,
		};
	}
	return @commits;
}

sub most_recent() {
	print $out "Most recent commits:\n\n";
	system 'git', 'rev-list', @rev_list_options, '--max-count=20', $new;
}

sub output_size() {
	$out->seek(0, 2);
	return $out->tell;
}

if ($old =~ /^0+$/) {
	# Creation of a branch
	$subj .= ' Created branch';
	my $copy_of = scan_branches();
	if (defined $copy_of) {
		$subj .= " as a copy of $copy_of";
		print $out "Created branch $ref as a copy of $copy_of ($new).\n";
	} else {
		print $out "Created branch $ref ($new).\n\n";
		most_recent();
	}
} elsif ($new =~ /^0+$/) {
	# Deletion of a branch
	$subj .= ' Branch deleted';
	print $out "Deleted branch $ref ($old).\n";
} else {
	my $lca = `git merge-base $old $new`; die if $?;
	chomp $lca;
	if ($lca eq $old) {
		# Fast forward ... scan all objects
		my @commits = scan_commits();
		my @nonmerges = grep { @{$_->{parents}} == 1 } @commits;
		@commits or exit;

		# Construct subject
		# Try to recognize simple merges and display them as such
		my $c0 = $commits[0];
		my $n0 = $nonmerges[0];
		my $c0p = $c0->{parents};
		if (@{$c0p} == 2 &&
		    $c0->{subject} =~ m{^\s*Merge branch '([^']*)'} &&
		    $1 ne $ref &&
		    ($c0p->[0] eq $old || $c0p->[1] eq $old)) {
			# Pushed a merge of a foreign branch to the current one
			$subj .= ' ' . $c0->{subject};
		} elsif ($n0) {
			# Otherwise take the subject of the first non-merge commit
			$subj .= ' ' . $n0->{subject};
		} else {
			# If there is none, take the first merge
			$subj .= ' ' . $c0->{subject};
		}

		print $out "Push to branch $ref ($old -> $new)\n\n";

		# If there are multiple commits, print an overall diffstat first
		if (@nonmerges > 1) {
			$subj .= ' [' . (scalar @commits) . ' commits]';
			print $out 'Pushed ', (scalar @commits), " commits. Overall diffstat:\n\n";
			system 'git', 'diff', '--stat', $old, $new;
			print $out "\n";
		}
		my $pos_after_header = output_size();

		# Show individual commits with diffs and stats
		system 'git', 'log', @rev_list_options, @diff_options, '-p', '--stat', "$old..$new";

		# If the file is too long, truncate it and print just a summary
		if (defined($max_diff_size) && output_size() > $max_diff_size) {
			$out->truncate($pos_after_header);
			output_size();
			print $out "Diff was too long, printing just a summary.\n\n";
			system 'git', 'log', @rev_list_options, "$old..$new";
		}
	} elsif ($lca eq $new) {
		# Rewind
		$subj .= ' Branch rewound';
		print $out "Rewound branch $ref ($old -> $new).\n\n";
		most_recent();
	} else {
		# Otherwise it is a rebase
		$subj .= ' Branch rebased';
		print $out "Rebased branch $ref ($old -> $new).\n\n";
		print $out "Commits from common ancestor:\n\n";
		system 'git', 'rev-list', @rev_list_options, $new, "^$old";
	}
}

$out->close();
if (defined $mail_to) {
	close STDIN;
	open STDIN, '<', $outname;
	system 'mutt',
		'-F/dev/null',
		'-x',
		'-e', 'set charset="utf-8"',
		'-e', 'set send_charset="us-ascii:iso-8859-2:utf-8"',
		'-e', "my_hdr X-Git-Repo: $repo",
		'-e', "my_hdr X-Git-Branch: $ref",
		'-e', "my_hdr X-Git-Old-SHA: $old",
		'-e', "my_hdr X-Git-New-SHA: $new",
		'-s', $subj,
		$mail_to;
} else {
	open STDOUT, '>&', \*ORIG_STDOUT;
	print "Subject: $subj\n\n";
	system 'cat', $outname;
}
